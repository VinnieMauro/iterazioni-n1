<!DOCTYPE html>
<html lang="en">
<head>
  <script>
    const ua = navigator.userAgent.toLowerCase();
    if (ua.includes("android")) {
      window.location.href = "/index-android.html";
    } else if (ua.includes("iphone") || ua.includes("ipad") || ua.includes("ipod")) {
      // stay on index.html
    } else {
      document.addEventListener("DOMContentLoaded", function() {
        document.body.innerHTML = "Unrecognized device.";
      });
    }
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Receiver AR + 3D Audio (module)</title>
  <style>
    body { margin: 0; overflow: hidden; }

    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 100;
    }

    #enableButton {
      margin-top: 20px;
      padding: 12px 24px;
      font-size: 18px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="overlay">
    Tap to enable audio, sensors, and AR
    <button id="enableButton">Enable</button>
  </div>

  <script type="module">
    import * as THREE from './libs/three.js/build/three.module.js';
    import { ARButton } from './libs/three.js/examples/jsm/webxr/ARButton.js';
    import { io } from './libs/socket.io/packages/socket.io/client-dist/socket.io.esm.min.js';

    const socket = io();
    let myId;
    socket.on('assignId', id => {
      myId = id;
      console.log('Assigned ID:', myId);
    });

    let camera, scene, renderer;
    let listener;
    const cubes = {};
    const positionalAudios = {};
    const peers = {};
    const streamSourceReady = { 1: false, 2: false };
    const initialCubePositions = { 1: null, 2: null };
    const buffers = {};
    let audioContext = null;

    // Reusable vectors for performance and stability
    const camWorldPos = new THREE.Vector3();
    const audioWorldPos = new THREE.Vector3();

    async function initAR() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 0);

      listener = new THREE.AudioListener();
      // camera.add(listener);  <-- removed as per instructions

      audioContext = listener.context;
      await audioContext.audioWorklet.addModule('circular-buffer-processor.js');

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

      const light = new THREE.HemisphereLight(0xffffff, 0x444444);
      scene.add(light);

      [1, 2].forEach(i => {
        const cube = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.2),
          new THREE.MeshStandardMaterial({ color: i === 1 ? 0xff0000 : 0x00ff00, transparent: true, opacity: 0.5 })
        );

        cubes[i] = cube;
        scene.add(cube);

        positionalAudios[i] = new THREE.PositionalAudio(listener);
        cube.add(positionalAudios[i]);

        // Attenuation setup
        positionalAudios[i].setRefDistance(0.2);
        positionalAudios[i].setRolloffFactor(1.5);
        positionalAudios[i].setDistanceModel('exponential');
        positionalAudios[i].setMaxDistance(20);
        positionalAudios[i].panner.panningModel = 'HRTF';
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function animate() {
      renderer.setAnimationLoop(() => {
        try {
          // Get XR camera group
          const xrCamGroup = renderer.xr.getCamera();
          // Extract world position from matrixWorld, reusing the vector
          camWorldPos.setFromMatrixPosition(xrCamGroup.matrixWorld);
          // Update audio listener based on matrixWorld (position + orientation)
          listener.position.copy(camWorldPos);
          listener.quaternion.setFromRotationMatrix(xrCamGroup.matrixWorld);
          listener.updateMatrixWorld();
          // For optional server updates use camWorldPos.x, camWorldPos.z

          // Update scene matrices for audio spatialization sync
          scene.updateMatrixWorld();

          // Manually sync the audio sources with cube positions
          [1, 2].forEach(i => {
            if (!streamSourceReady[i] || !positionalAudios[i].panner) return;
            cubes[i].getWorldPosition(audioWorldPos);
            positionalAudios[i].panner.setPosition(audioWorldPos.x, audioWorldPos.y, audioWorldPos.z);
          });

          // Send listener (XR camera) position to the server
          socket.emit('listener-position', {
            id: myId,
            x: camWorldPos.x,
            z: camWorldPos.z
          });

          renderer.render(scene, camera);
        } catch (e) {
          console.error('Render loop error:', e);
        }
      });
    }

    document.getElementById('enableButton').onclick = async () => {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
          await DeviceMotionEvent.requestPermission();
        }
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
        document.getElementById('overlay').style.display = 'none';
        await initAR();
        socket.emit('receiver-ready');
      } catch (e) {
        alert('âŒ Error enabling sensors or audio: ' + e.message);
        console.error(e);
      }
    };

    socket.on('webrtc-offer', async ({ from, offer, cubeIndex }) => {
      const key = `${from}-${cubeIndex}`;
      if (peers[key]) {
        peers[key].close();
        delete peers[key];
      }

      const peer = new RTCPeerConnection();

      peer.ontrack = (event) => {
        const stream = event.streams[0];
        const source = audioContext.createMediaStreamSource(stream);
        const scriptProcessor = audioContext.createScriptProcessor(1024, 1, 1);
        const worklet = new AudioWorkletNode(audioContext, 'circular-buffer-processor');

        source.connect(scriptProcessor);
        scriptProcessor.connect(audioContext.destination);
        scriptProcessor.onaudioprocess = (e) => {
          const samples = e.inputBuffer.getChannelData(0);
          worklet.port.postMessage(samples.slice(0));
        };

        scriptProcessor.connect(worklet);
        positionalAudios[cubeIndex].setNodeSource(worklet);
        buffers[cubeIndex] = worklet;
        streamSourceReady[cubeIndex] = true;

        if (initialCubePositions[cubeIndex]) {
          const { x, y, z } = initialCubePositions[cubeIndex];
          cubes[cubeIndex].position.set(x, y, z);
          initialCubePositions[cubeIndex] = null;
        }
      };

      peer.onicecandidate = (e) => {
        if (e.candidate) {
          socket.emit('webrtc-candidate', { target: from, candidate: e.candidate, cubeIndex });
        }
      };

      await peer.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);
      socket.emit('webrtc-answer', { target: from, answer: peer.localDescription, cubeIndex });

      peers[key] = peer;
    });

    socket.on('webrtc-candidate', ({ from, candidate, cubeIndex }) => {
      const key = `${from}-${cubeIndex}`;
      if (peers[key]) {
        peers[key].addIceCandidate(new RTCIceCandidate(candidate));
      }
    });

    socket.on('move-cube', ({ index, x, y, z }) => {
      if (cubes[index] && streamSourceReady[index]) {
        cubes[index].position.set(x, y, z);
      } else {
        initialCubePositions[index] = { x, y, z };
      }
    });
  </script>
</body>
</html>