<!DOCTYPE html>
<html lang="it">
<head>
  <script>
    const ua = navigator.userAgent.toLowerCase();
    if (ua.includes("android")) {
      window.location.href = "/index-android.html";
    } else if (ua.includes("iphone") || ua.includes("ipad") || ua.includes("ipod")) {
      // resta su index.html
    } else {
      document.addEventListener("DOMContentLoaded", function() {
        document.body.innerHTML = "Dispositivo non riconosciuto.";
      });
    }
  </script>
  <meta charset="UTF-8" />
  <title>Receiver AR + Audio 3D (module)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 100;
    }
    #enableButton {
      margin-top: 20px;
      padding: 12px 24px;
      font-size: 18px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="overlay">
    Tocca per abilitare audio, sensori e AR
    <button id="enableButton">Abilita</button>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/webxr/ARButton.js';
    import { io } from 'https://cdn.socket.io/4.5.4/socket.io.esm.min.js';

    const socket = io();

    let camera, scene, renderer;
    let listener;
    const cubes = {};
    const positionalAudios = {};
    const peers = {};
    const streamSourceReady = { 1: false, 2: false };
    const initialCubePositions = { 1: null, 2: null };
    const buffers = {};
    let audioContext = null;

    async function initAR() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 0);

      listener = new THREE.AudioListener();
      camera.add(listener);

      audioContext = listener.context;
      await audioContext.audioWorklet.addModule('circular-buffer-processor.js');

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

      const light = new THREE.HemisphereLight(0xffffff, 0x444444);
      scene.add(light);

      [1, 2].forEach(i => {
        cubes[i] = new THREE.Mesh(
          new THREE.BoxGeometry(),
          new THREE.MeshStandardMaterial({ color: i === 1 ? 0xff0000 : 0x00ff00 })
        );
        scene.add(cubes[i]);

        positionalAudios[i] = new THREE.PositionalAudio(listener);
        positionalAudios[i].setRefDistance(0.2);
        positionalAudios[i].setRolloffFactor(1);
        positionalAudios[i].setDistanceModel('exponential');
        positionalAudios[i].panner.panningModel = 'HRTF';
        cubes[i].add(positionalAudios[i]);
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function animate() {
      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);
        
        // Aggiorna listener position e orientation
        listener.position.copy(camera.position);
        listener.quaternion.copy(camera.quaternion);
        listener.updateMatrixWorld();
        
        // CORREZIONE ALLINEAMENTO: Forza l'aggiornamento delle posizioni audio
        Object.keys(positionalAudios).forEach(i => {
          if (positionalAudios[i] && cubes[i]) {
            // Copia la posizione del cubo nell'audio
            positionalAudios[i].position.copy(cubes[i].position);
            positionalAudios[i].updateMatrixWorld();
          }
        });
        
        // DEBUG ogni 2 secondi (120 frame a 60fps)
        if (renderer.info.render.frame % 120 === 0) {
          console.log('ðŸŽ§ Listener:', {
            pos: listener.position,
            rot: listener.quaternion
          });
          Object.keys(cubes).forEach(i => {
            if (cubes[i] && positionalAudios[i]) {
              console.log(`ðŸ“¦ Cubo ${i}:`, {
                cubePos: cubes[i].position,
                audioPos: positionalAudios[i].position,
                aligned: cubes[i].position.equals(positionalAudios[i].position)
              });
            }
          });
        }
      });
    }

    document.getElementById('enableButton').onclick = async () => {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
          await DeviceMotionEvent.requestPermission();
        }
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
        document.getElementById('overlay').style.display = 'none';
        await initAR();
        socket.emit('receiver-ready');
      } catch (e) {
        alert('âŒ Errore permessi sensori o audio: ' + e.message);
        console.error(e);
      }
    };

    socket.on('webrtc-offer', async ({ from, offer, cubeIndex }) => {
      const key = `${from}-${cubeIndex}`;
      if (peers[key]) {
        peers[key].close();
        delete peers[key];
      }

      const peer = new RTCPeerConnection();

      peer.ontrack = (event) => {
        const stream = event.streams[0];
        console.log(`ðŸŽ§ Stream ricevuto per cubo ${cubeIndex}`, stream);

        const source = audioContext.createMediaStreamSource(stream);
        const scriptProcessor = audioContext.createScriptProcessor(1024, 1, 1);
        const worklet = new AudioWorkletNode(audioContext, 'circular-buffer-processor');

        source.connect(scriptProcessor);
        scriptProcessor.connect(audioContext.destination);
        scriptProcessor.onaudioprocess = (e) => {
          const samples = e.inputBuffer.getChannelData(0);
          worklet.port.postMessage(samples.slice(0));
        };

        positionalAudios[cubeIndex].setNodeSource(worklet);
        buffers[cubeIndex] = worklet;
        streamSourceReady[cubeIndex] = true;

        // CORREZIONE: Forza l'allineamento subito dopo aver collegato l'audio
        if (initialCubePositions[cubeIndex]) {
          const { x, y, z } = initialCubePositions[cubeIndex];
          cubes[cubeIndex].position.set(x, y, z);
          positionalAudios[cubeIndex].position.set(x, y, z);
          positionalAudios[cubeIndex].updateMatrixWorld();
          initialCubePositions[cubeIndex] = null;
        }

        console.log(`ðŸ”Š Flusso audio collegato cubo #${cubeIndex}`);
      };

      peer.onicecandidate = (e) => {
        if (e.candidate) {
          socket.emit('webrtc-candidate', { target: from, candidate: e.candidate, cubeIndex });
        }
      };

      await peer.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);
      socket.emit('webrtc-answer', { target: from, answer: peer.localDescription, cubeIndex });

      peers[key] = peer;
    });

    socket.on('webrtc-candidate', ({ from, candidate, cubeIndex }) => {
      const key = `${from}-${cubeIndex}`;
      if (peers[key]) {
        peers[key].addIceCandidate(new RTCIceCandidate(candidate));
      }
    });

    socket.on('move-cube', ({ index, x, y, z }) => {
      if (cubes[index] && streamSourceReady[index]) {
        // Aggiorna sia cubo che audio contemporaneamente
        cubes[index].position.set(x, y, z);
        positionalAudios[index].position.set(x, y, z);
        positionalAudios[index].updateMatrixWorld();
        console.log(`ðŸ“¦ðŸ”Š Cubo ${index} e audio spostati a: x:${x}, y:${y}, z:${z}`);
      } else {
        initialCubePositions[index] = { x, y, z };
        console.log(`ðŸ“¦ Posizione salvata per cubo ${index}:`, initialCubePositions[index]);
      }
    });
  </script>
</body>
</html>
