<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Receiver AR + Audio 3D - Android</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 100;
    }
    #enableButton {
      margin-top: 20px;
      padding: 12px 24px;
      font-size: 18px;
      cursor: pointer;
    }
    #tone-controls {
      position: absolute; 
      top: 10px; 
      left: 10px; 
      z-index: 101; 
      display: flex; 
      gap: 10px;
    }
  </style>
</head>
<body>
  <div id="overlay">
    Tocca per abilitare audio, sensori e AR
    <button id="enableButton">Abilita</button>
  </div>
  <div id="tone-controls">
    <button id="toggleRedTone">Cubo Rosso: ON/OFF</button>
    <button id="toggleGreenTone">Cubo Verde: ON/OFF</button>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/webxr/ARButton.js';
    import { io } from 'https://cdn.socket.io/4.5.4/socket.io.esm.min.js';



    const socket = io();

    let camera, scene, renderer;
    let listener;
    const cubes = {};
    const positionalAudios = {};
    const peers = {};
    const streamSourceReady = { 1: false, 2: false };
    const initialCubePositions = { 1: null, 2: null };
    const buffers = {};
    let audioContext = null;


    // Oscillator nodes e flag per toni
    const oscillatorNodes = { 1: null, 2: null };
    const toneEnabled = { 1: false, 2: false };


document.getElementById('enableButton').onclick = async () => {
  try {
    await initAR();

    socket.on('webrtc-offer', async ({ from, offer, cubeIndex }) => {
      const key = `${from}-${cubeIndex}`;
      console.log(`‚û°Ô∏è Ricevuta offerta WebRTC da ${from} per il cubo ${cubeIndex}`);
      if (peers[key]) {
        console.log(`üîÑ Esiste gi√† una connessione peer per ${key}, la chiudo.`);
        peers[key].close();
        delete peers[key];
      }

      console.log('üÜï Creo nuovo RTCPeerConnection...');
      const peer = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      peer.ontrack = (event) => {
        console.log('üîä Ricevuto nuovo track event dal peer.');
        const stream = event.streams[0];
        // Mantieni il nodo audio per la decodifica, ma silenzia completamente l‚Äôuscita audio
        const directAudio = document.createElement('audio');
        directAudio.srcObject = stream;
        directAudio.muted = true;
        directAudio.autoplay = true;
        directAudio.style.display = 'none';
        document.body.appendChild(directAudio);
        try {
          console.log('üéõÔ∏è Creo sorgente MediaStream per l\'audio.');
          const mediaSource = audioContext.createMediaStreamSource(stream);
          // --- INIZIO PATCH: Mantieni la traccia audio "utilizzata" ma silenziosa ---
          const silentGain = audioContext.createGain();
          silentGain.gain.value = 0.0001;
          mediaSource.connect(silentGain);
          silentGain.connect(audioContext.destination);
          // --- FINE PATCH ---
          const processor = audioContext.createScriptProcessor(2048, 1, 1);
          mediaSource.connect(processor);
          const activationGain = audioContext.createGain();
          activationGain.gain.value = 0.0001;
          processor.connect(activationGain);
          activationGain.connect(audioContext.destination);
          processor.onaudioprocess = (event) => {
            const input = event.inputBuffer.getChannelData(0);
            console.log(`üîÅ Received ${input.length} samples for cube ${cubeIndex}`);
            // showLog(`üîÅ Received ${input.length} samples for cube ${cubeIndex}`);
            const targetBuffer = buffers[cubeIndex];
            for (let i = 0; i < input.length; i++) {
              targetBuffer.push(input[i]);
            }
          };

          streamSourceReady[cubeIndex] = true;
          console.log(`‚úÖ Stream audio pronto per il cubo ${cubeIndex}.`);

          if (initialCubePositions[cubeIndex]) {
            const { x, y, z } = initialCubePositions[cubeIndex];
            cubes[cubeIndex].position.set(x, y, z);
            positionalAudios[cubeIndex].position.set(x, y, z);
            positionalAudios[cubeIndex].updateMatrixWorld();
            initialCubePositions[cubeIndex] = null;
          }
        } catch (error) {
          console.error('‚ùå Errore nella gestione del track event:', error);
        }
      };

      peer.onicecandidate = (e) => {
        if (e.candidate) {
          console.log('üßä Nuovo candidato ICE generato, lo invio al mittente.');
          socket.emit('webrtc-candidate', { target: from, candidate: e.candidate, cubeIndex });
        }
      };

      try {
        console.log('üì° Setting remote description...');
        await peer.setRemoteDescription(new RTCSessionDescription(offer));

        console.log('üß† Creating answer...');
        const answer = await peer.createAnswer();

        console.log('üì® Setting local description...');
        await peer.setLocalDescription(answer);

        console.log('üì§ Sending WebRTC answer...');
        socket.emit('webrtc-answer', { target: from, answer: peer.localDescription, cubeIndex });

        peers[key] = peer;
      } catch (error) {
        console.error('‚ùå WebRTC negotiation failed:', error);
      }
    });

    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      await DeviceMotionEvent.requestPermission();
    }

    document.getElementById('overlay').style.display = 'none';

    if (audioContext.state === 'suspended') {
      await audioContext.resume();
    }
    console.log('üéß AudioContext stato:', audioContext.state);

    // Nessun routing diretto all'output

    socket.emit('receiver-ready');
  } catch (e) {
    console.error(e);
    alert('Errore: ' + e.message);
  }
};


    async function initAR() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 0);

      listener = new THREE.AudioListener();
      camera.add(listener);
      audioContext = listener.context;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      try {
        const arBtn = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
        document.body.appendChild(arBtn);
      } catch (err) {}

      const light = new THREE.HemisphereLight(0xffffff, 0x444444);
      scene.add(light);

      [1, 2].forEach(i => {
        cubes[i] = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.5, 0.5),
          new THREE.MeshStandardMaterial({ 
            color: i === 1 ? 0xff0000 : 0x00ff00,
            emissive: i === 1 ? 0x330000 : 0x003300
          })
        );
        
        cubes[i].position.set(i === 1 ? -1 : 1, 0.5, -1.5);
        cubes[i].visible = true;
        scene.add(cubes[i]);

        positionalAudios[i] = new THREE.PositionalAudio(listener);
        positionalAudios[i].setRefDistance(0.2);
        positionalAudios[i].setRolloffFactor(2);
        positionalAudios[i].setDistanceModel('exponential');
        positionalAudios[i].setMaxDistance(20);
        positionalAudios[i].setVolume(1.0);
        if (positionalAudios[i].panner) {
          positionalAudios[i].panner.panningModel = 'HRTF';
          positionalAudios[i].panner.distanceModel = 'exponential';
          positionalAudios[i].panner.refDistance = 0.2;
          positionalAudios[i].panner.rolloffFactor = 2;
          positionalAudios[i].panner.maxDistance = 20;
        }
        cubes[i].add(positionalAudios[i]);

        buffers[i] = [];

        const outputProcessor = audioContext.createScriptProcessor(2048, 0, 1);
        outputProcessor.onaudioprocess = (event) => {
          const outputData = event.outputBuffer.getChannelData(0);
          const buffer = buffers[i];
          if (!toneEnabled[i] && buffer.length >= outputData.length) {
            for (let j = 0; j < outputData.length; j++) {
              outputData[j] = buffer.shift();
            }
          } else {
            outputData.fill(0);
          }
        };
        positionalAudios[i].setNodeSource(outputProcessor);
        positionalAudios[i].play();

        // Oscillatore inizialmente null
        oscillatorNodes[i] = null;
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);

        listener.position.copy(camera.position);
        listener.quaternion.copy(camera.quaternion);
        listener.updateMatrixWorld();

        Object.keys(positionalAudios).forEach(i => {
          if (positionalAudios[i] && cubes[i]) {
            positionalAudios[i].position.copy(cubes[i].position);
            positionalAudios[i].updateMatrixWorld();
          }
        });
      });
    }



    socket.on('webrtc-candidate', ({ from, candidate, cubeIndex }) => {
      const key = `${from}-${cubeIndex}`;
      if (peers[key]) {
        peers[key].addIceCandidate(new RTCIceCandidate(candidate));
      }
    });

socket.on('move-cube', ({ index, x, y, z }) => {
  if (cubes[index]) {
    cubes[index].position.set(x, y, z);
    if (positionalAudios[index]) {
      positionalAudios[index].position.set(x, y, z);
      positionalAudios[index].updateMatrixWorld();
    }
  } else {
    initialCubePositions[index] = { x, y, z };
  }
});


    // Controlli toni
    document.getElementById("toggleRedTone").onclick = () => toggleTone(1);
    document.getElementById("toggleGreenTone").onclick = () => toggleTone(2);

    function toggleTone(index) {
      if (!positionalAudios[index]) return;
      if (!toneEnabled[index]) {
        // Attiva tono: crea oscillator e collega a positionalAudio
        if (oscillatorNodes[index]) {
          oscillatorNodes[index].stop();
          oscillatorNodes[index].disconnect();
          oscillatorNodes[index] = null;
        }
        const oscillator = audioContext.createOscillator();
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(index === 1 ? 440 : 660, audioContext.currentTime);
        oscillator.start();

        // Disconnetti eventuale source precedente
        if (positionalAudios[index].source) {
          positionalAudios[index].source.disconnect();
        }

        oscillator.connect(positionalAudios[index].getOutput());
        positionalAudios[index].setNodeSource(oscillator);
        positionalAudios[index].play();

        oscillatorNodes[index] = oscillator;
        toneEnabled[index] = true;
        positionalAudios[index].setVolume(1.0);
      } else {
        // Disattiva tono: ferma oscillator e ripristina buffer circolare
        if (oscillatorNodes[index]) {
          oscillatorNodes[index].stop();
          oscillatorNodes[index].disconnect();
          oscillatorNodes[index] = null;
        }
        toneEnabled[index] = false;

        // Ripristina scriptProcessor per buffer FIFO
        const outputProcessor = audioContext.createScriptProcessor(2048, 0, 1);
        outputProcessor.onaudioprocess = (event) => {
          const outputData = event.outputBuffer.getChannelData(0);
          const buffer = buffers[index];
          if (!toneEnabled[index] && buffer.length >= outputData.length) {
            for (let j = 0; j < outputData.length; j++) {
              outputData[j] = buffer.shift();
            }
          } else {
            outputData.fill(0);
          }
        };
        positionalAudios[index].setNodeSource(outputProcessor);
        positionalAudios[index].play();

        positionalAudios[index].setVolume(1.0);
      }
    }
  </script>
</body>
</html>