<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Sender + 2D Map</title>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    section {
      width: 100%;
      max-width: 900px;
      padding: 20px;
      box-sizing: border-box;
    }
    #sender-section {
      background: #fafafa;
      border-bottom: 2px solid #ccc;
    }
    #map-section {
      background: #fff;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 20px;
    }
    .map-container {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      width: 100%;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f8f8f8;
      display: inline-block;
    }
    button, select {
      padding: 10px 20px;
      margin: 5px 10px 5px 0;
      font-size: 16px;
    }
    label { margin-right: 8px; }
    .status {
      background: #f0f0f0;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
      font-family: monospace;
    }
  </style>
</head>
<body>

  <!-- ==================== SENDER SECTION ==================== -->
  <section id="sender-section">
    <h1>Audio Sender + Cube Controller</h1>

    <label for="inputDevice">Select audio input device:</label>
    <select id="inputDevice"></select>

    <br><br>
    <button id="start">Start streaming</button>
    <button id="moveRed">Move red cube</button>
    <button id="moveGreen">Move green cube</button>

    <div id="status" class="status">Status: Waiting...</div>

    <script>
      const socket = io();

      socket.emit("sender-ready");
      socket.on("connect", () => {
        socket.emit("sender-ready");
        updateStatus("ðŸ”„ sender-ready re-emitted after reconnect");
      });

      const peers = new Map();
      const audioContexts = new Map();
      let selectedDeviceId = null;
      const deviceSelect = document.getElementById("inputDevice");
      const statusDiv = document.getElementById("status");

      function updateStatus(msg) {
        statusDiv.textContent = `Status: ${msg}`;
        console.log(msg);
      }

      async function requestAudioPermission() {
        try {
          const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          tempStream.getTracks().forEach(track => track.stop());
          updateStatus("Microphone permission granted");
        } catch (e) {
          updateStatus("âŒ Microphone permission denied");
        }
      }

      async function enumerateDevices() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        deviceSelect.innerHTML = "";
        
        const audioInputs = devices.filter(d => d.kind === "audioinput");
        audioInputs.forEach(device => {
          const option = document.createElement("option");
          option.value = device.deviceId;
          option.text = device.label || `Input ${device.deviceId.substring(0, 8)}...`;
          deviceSelect.appendChild(option);
        });
        
        if (deviceSelect.options.length > 0) {
          selectedDeviceId = deviceSelect.value;
          updateStatus(`${audioInputs.length} audio input(s) found`);
        } else {
          updateStatus("âŒ No audio input devices found");
        }
      }

      deviceSelect.onchange = () => {
        selectedDeviceId = deviceSelect.value;
        updateStatus(`Selected device: ${deviceSelect.options[deviceSelect.selectedIndex].text}`);
      };

      async function createMonoStream(deviceId, channelIndex) {
        try {
          const ctx = new AudioContext();
          const originalStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              deviceId: { exact: deviceId },
              channelCount: 2,
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false,
              sampleRate: 48000
            }
          });

          updateStatus(`Original stream obtained for channel ${channelIndex}`);

          const source = ctx.createMediaStreamSource(originalStream);
          const splitter = ctx.createChannelSplitter(2);
          const merger = ctx.createChannelMerger(1);
          const destination = ctx.createMediaStreamDestination();

          source.connect(splitter);
          splitter.connect(merger, channelIndex, 0);
          merger.connect(destination);

          audioContexts.set(`${deviceId}-${channelIndex}`, {
            context: ctx,
            originalStream,
            destination
          });

          updateStatus(`âœ… Mono stream created for channel ${channelIndex}`);
          return destination.stream;
          
        } catch (error) {
          updateStatus(`âŒ Error creating mono stream for channel ${channelIndex}: ${error.message}`);
          throw error;
        }
      }

      async function createPeer(receiverId, cubeIndex) {
        if (!selectedDeviceId) {
          updateStatus("âš ï¸ Select an audio device before starting");
          return;
        }
        
        try {
          const channelIndex = cubeIndex - 1;
          const audioKey = `${selectedDeviceId}-${channelIndex}`;
          let stream;
          if (audioContexts.has(audioKey)) {
            stream = audioContexts.get(audioKey).destination.stream;
          } else {
            stream = await createMonoStream(selectedDeviceId, channelIndex);
          }
          
          updateStatus(`ðŸŽ¤ Stream ready for cube ${cubeIndex} (channel ${channelIndex})`);

          const peer = new RTCPeerConnection({ iceServers: [] });

          stream.getTracks().forEach(track => {
            peer.addTrack(track, stream);
            updateStatus(`ðŸŽµ Track added for cube ${cubeIndex}: ${track.kind}`);
          });

          peer.onicecandidate = e => {
            if (e.candidate) {
              socket.emit("webrtc-candidate", {
                target: receiverId,
                candidate: e.candidate,
                cubeIndex
              });
            }
          };

          peer.onconnectionstatechange = () => {
            updateStatus(`ðŸ”— Connection state for cube ${cubeIndex}: ${peer.connectionState}`);
            if (["disconnected","failed","closed"].includes(peer.connectionState)) {
              const key = `${receiverId}-${cubeIndex}`;
              if (peers.has(key)) {
                peers.get(key).close();
                peers.delete(key);
                updateStatus(`âŒ Peer removed for receiver ${receiverId}, cube ${cubeIndex}`);
              }
            }
          };

          const offer = await peer.createOffer();
          await peer.setLocalDescription(offer);
          
          socket.emit("webrtc-offer", {
            target: receiverId,
            offer: peer.localDescription,
            cubeIndex
          });

          peers.set(`${receiverId}-${cubeIndex}`, peer);
          updateStatus(`ðŸ”” Peer created for receiver ${receiverId}, cube ${cubeIndex}`);
          
        } catch (error) {
          updateStatus(`âŒ Error creating peer: ${error.message}`);
        }
      }

      socket.on("new-receiver", async ({ receiverId }) => {
        updateStatus(`ðŸŽ¯ New receiver detected: ${receiverId}`);
        for (const cubeIndex of [1, 2]) {
          const key = `${receiverId}-${cubeIndex}`;
          if (peers.has(key)) {
            peers.get(key).close();
            peers.delete(key);
            updateStatus(`â™»ï¸ Previous peer closed for cube ${cubeIndex}`);
          }
        }
        setTimeout(async () => {
          await createPeer(receiverId, 1);
          await createPeer(receiverId, 2);
          updateStatus(`âœ… Peers created for receiver ${receiverId}`);
        }, 300);
      });

      socket.on("webrtc-answer", ({ from, answer, cubeIndex }) => {
        const key = `${from}-${cubeIndex}`;
        if (peers.has(key)) {
          peers.get(key).setRemoteDescription(new RTCSessionDescription(answer));
          updateStatus(`ðŸ›Žï¸ Answer received from ${from} for cube ${cubeIndex}`);
        }
      });

      socket.on("webrtc-candidate", ({ from, candidate, cubeIndex }) => {
        const key = `${from}-${cubeIndex}`;
        if (peers.has(key)) {
          peers.get(key).addIceCandidate(new RTCIceCandidate(candidate));
          updateStatus(`ðŸ“¡ Candidate added for cube ${cubeIndex}`);
        }
      });

      document.getElementById("start").onclick = () => {
        if (!selectedDeviceId) {
          updateStatus("âš ï¸ Select an audio input before starting");
          return;
        }
        updateStatus("âœ… Sender ready, waiting for receivers...");
      };

      function sendPosition(index, x, y, z) {
        socket.emit("move-cube", { index, x, y, z });
        updateStatus(`ðŸ“¡ Cube ${index===1?'red':'green'} moved to x:${x.toFixed(2)}, y:${y.toFixed(2)}, z:${z.toFixed(2)}`);
      }

      document.getElementById("moveRed").onclick = () => sendPosition(1, Math.random()*4-2, 0, Math.random()*-4);
      document.getElementById("moveGreen").onclick = () => sendPosition(2, Math.random()*4-2, 0, Math.random()*-4);

      window.addEventListener('beforeunload', () => {
        peers.forEach(peer => peer.close());
        audioContexts.forEach(({ context, originalStream }) => {
          originalStream.getTracks().forEach(t => t.stop());
          if (context.state !== 'closed') context.close();
        });
      });

      (async () => {
        await requestAudioPermission();
        await enumerateDevices();
        updateStatus("ðŸŽ¬ Initialization complete");
      })();
    </script>
  </section>

  <!-- ==================== MAP SECTION ==================== -->
  <section id="map-section">
    <div class="map-container">
      <canvas id="mapCanvas" width="400" height="400"></canvas>
      <canvas id="sideCanvas" width="400" height="400"></canvas>
    </div>

    <script type="module">
      import { io } from './libs/socket.io/packages/socket.io/client-dist/socket.io.esm.min.js';
      const socketMap = io();
      socketMap.emit('receiver-ready');

      const mapCanvas = document.getElementById('mapCanvas');
      const mapCtx = mapCanvas.getContext('2d');
      const sideCanvas = document.getElementById('sideCanvas');
      const sideCtx = sideCanvas.getContext('2d');

      const positions = {
        1: { x: 0, y: 0, z: 0 },
        2: { x: 0, y: 0, z: 0 },
        listeners: {}
      };

      function drawTopView() {
        mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
        mapCtx.save();
        mapCtx.translate(mapCanvas.width / 2, mapCanvas.height / 2);
        mapCtx.font = '12px sans-serif';

        mapCtx.fillStyle = 'red';
        mapCtx.fillRect(positions[1].x * 20 - 5, positions[1].z * 20 - 5, 10, 10);
        mapCtx.fillText(`(${positions[1].x.toFixed(1)}, ${positions[1].z.toFixed(1)})`, positions[1].x * 20 - 20, positions[1].z * 20 - 10);

        mapCtx.fillStyle = 'green';
        mapCtx.fillRect(positions[2].x * 20 - 5, positions[2].z * 20 - 5, 10, 10);
        mapCtx.fillText(`(${positions[2].x.toFixed(1)}, ${positions[2].z.toFixed(1)})`, positions[2].x * 20 - 20, positions[2].z * 20 - 10);

        for (const id in positions.listeners) {
          const pos = positions.listeners[id];
          mapCtx.fillStyle = 'blue';
          mapCtx.beginPath();
          mapCtx.arc(pos.x * 20, pos.z * 20, 6, 0, 2 * Math.PI);
          mapCtx.fill();
          mapCtx.fillText(`${id.slice(0,6)}`, pos.x * 20 + 8, pos.z * 20);
          mapCtx.fillText(`(${pos.x.toFixed(1)}, ${pos.z.toFixed(1)})`, pos.x * 20 - 20, pos.z * 20 - 10);
        }

        mapCtx.restore();
      }

      function drawSideView() {
        sideCtx.clearRect(0, 0, sideCanvas.width, sideCanvas.height);
        sideCtx.save();
        sideCtx.translate(sideCanvas.width / 2, sideCanvas.height / 2);
        sideCtx.font = '12px sans-serif';

        sideCtx.fillStyle = 'red';
        sideCtx.fillRect(positions[1].x * 20 - 5, -positions[1].y * 20 - 5, 10, 10);
        sideCtx.fillText(`(${positions[1].x.toFixed(1)}, ${positions[1].y.toFixed(1)})`, positions[1].x * 20 - 20, -positions[1].y * 20 - 10);

        sideCtx.fillStyle = 'green';
        sideCtx.fillRect(positions[2].x * 20 - 5, -positions[2].y * 20 - 5, 10, 10);
        sideCtx.fillText(`(${positions[2].x.toFixed(1)}, ${positions[2].y.toFixed(1)})`, positions[2].x * 20 - 20, -positions[2].y * 20 - 10);

        for (const id in positions.listeners) {
          const pos = positions.listeners[id];
          sideCtx.fillStyle = 'blue';
          sideCtx.beginPath();
          sideCtx.arc(pos.x * 20, -pos.y * 20, 6, 0, 2 * Math.PI);
          sideCtx.fill();
          sideCtx.fillText(`${id.slice(0,6)}`, pos.x * 20 + 8, -pos.y * 20);
          sideCtx.fillText(`(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`, pos.x * 20 - 20, -pos.y * 20 - 10);
        }

        sideCtx.restore();
      }

      function draw() { drawTopView(); drawSideView(); }

      socketMap.on('move-cube', ({ index, x, y, z }) => {
        positions[index] = { x, y, z };
        draw();
      });

      socketMap.on('listener-position', ({ id, x, y = 0, z }) => {
        positions.listeners[id] = { x, y, z };
        draw();
      });

      socketMap.on('listener-disconnected', id => {
        delete positions.listeners[id];
        draw();
      });

      draw();
    </script>
  </section>

</body>
</html>