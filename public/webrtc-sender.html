<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Sender Multi-cubo</title>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    button, select { padding: 10px 20px; margin: 5px 10px 5px 0; font-size: 16px; }
    label { margin-right: 8px; }
    .status { 
      background: #f0f0f0; 
      padding: 10px; 
      margin: 10px 0; 
      border-radius: 5px; 
      font-family: monospace; 
    }
  </style>
</head>
<body>
  <h1>Sender Audio + Controllo Cubi</h1>

  <label for="inputDevice">Scegli periferica audio:</label>
  <select id="inputDevice"></select>

  <br><br>
  <button id="start">Avvia streaming</button>
  <button id="moveRed">Sposta cubo rosso</button>
  <button id="moveGreen">Sposta cubo verde</button>
  
  <div id="status" class="status">
    Status: In attesa...
  </div>

  <script>
    const socket = io();

    // Emetto sender-ready all'inizio e ad ogni riconnessione
    socket.emit("sender-ready");
    socket.on("connect", () => {
      socket.emit("sender-ready");
      updateStatus("ðŸ”„ sender-ready ritrasmesso dopo connect");
    });

    const peers = new Map();
    const audioContexts = new Map(); // Un context per ogni canale
    let selectedDeviceId = null;
    const deviceSelect = document.getElementById("inputDevice");
    const statusDiv = document.getElementById("status");

    function updateStatus(msg) {
      statusDiv.textContent = `Status: ${msg}`;
      console.log(msg);
    }

    async function requestAudioPermission() {
      try {
        const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        tempStream.getTracks().forEach(track => track.stop());
        updateStatus("Permessi audio ottenuti");
      } catch (e) {
        alert("Permesso audio necessario");
        updateStatus("âŒ Permessi audio negati");
      }
    }

    async function enumerateDevices() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      deviceSelect.innerHTML = "";
      
      const audioInputs = devices.filter(d => d.kind === "audioinput");
      audioInputs.forEach(device => {
        const option = document.createElement("option");
        option.value = device.deviceId;
        option.text = device.label || `Input ${device.deviceId.substring(0, 8)}...`;
        deviceSelect.appendChild(option);
      });
      
      if (deviceSelect.options.length > 0) {
        selectedDeviceId = deviceSelect.value;
        updateStatus(`${audioInputs.length} dispositivi audio trovati`);
      } else {
        updateStatus("âŒ Nessun dispositivo audio trovato");
      }
    }

    deviceSelect.onchange = () => {
      selectedDeviceId = deviceSelect.value;
      updateStatus(`Dispositivo selezionato: ${deviceSelect.options[deviceSelect.selectedIndex].text}`);
    };

    async function createMonoStream(deviceId, channelIndex) {
      try {
        const ctx = new AudioContext();
        const originalStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            deviceId: { exact: deviceId },
            channelCount: 2,
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
            sampleRate: 48000
          }
        });

        updateStatus(`Stream originale ottenuto per canale ${channelIndex}`);

        const source = ctx.createMediaStreamSource(originalStream);
        const splitter = ctx.createChannelSplitter(2);
        const merger = ctx.createChannelMerger(1);
        const destination = ctx.createMediaStreamDestination();

        source.connect(splitter);
        splitter.connect(merger, channelIndex, 0);
        merger.connect(destination);

        audioContexts.set(`${deviceId}-${channelIndex}`, {
          context: ctx,
          originalStream,
          destination
        });

        updateStatus(`âœ… Stream mono creato per canale ${channelIndex}`);
        return destination.stream;
        
      } catch (error) {
        updateStatus(`âŒ Errore creazione stream canale ${channelIndex}: ${error.message}`);
        throw error;
      }
    }

    async function createPeer(receiverId, cubeIndex) {
      if (!selectedDeviceId) {
        alert("Seleziona una periferica audio!");
        return;
      }
      
      try {
        const channelIndex = cubeIndex - 1;
        const audioKey = `${selectedDeviceId}-${channelIndex}`;
        let stream;
        if (audioContexts.has(audioKey)) {
          stream = audioContexts.get(audioKey).destination.stream;
        } else {
          stream = await createMonoStream(selectedDeviceId, channelIndex);
        }
        
        updateStatus(`ðŸŽ¤ Stream pronto per cubo ${cubeIndex} (canale ${channelIndex})`);

       const peer = new RTCPeerConnection({
          iceServers: [] // ðŸ”‡ Nessun STUN server, solo LAN
});

        stream.getTracks().forEach(track => {
          peer.addTrack(track, stream);
          updateStatus(`ðŸŽµ Traccia aggiunta per cubo ${cubeIndex}: ${track.kind}`);
        });

        peer.onicecandidate = e => {
          if (e.candidate) {
            socket.emit("webrtc-candidate", {
              target: receiverId,
              candidate: e.candidate,
              cubeIndex
            });
          }
        };

        peer.onconnectionstatechange = () => {
          updateStatus(`ðŸ”— Connessione cubo ${cubeIndex}: ${peer.connectionState}`);
          if (["disconnected","failed","closed"].includes(peer.connectionState)) {
            const key = `${receiverId}-${cubeIndex}`;
            if (peers.has(key)) {
              peers.get(key).close();
              peers.delete(key);
              updateStatus(`âŒ Peer eliminato per receiver ${receiverId} cubo ${cubeIndex}`);
            }
          }
        };

        const offer = await peer.createOffer();
        await peer.setLocalDescription(offer);
        
        socket.emit("webrtc-offer", {
          target: receiverId,
          offer: peer.localDescription,
          cubeIndex
        });

        peers.set(`${receiverId}-${cubeIndex}`, peer);
        updateStatus(`ðŸ”” Peer creato per receiver ${receiverId} cubo ${cubeIndex}`);
        
      } catch (error) {
        updateStatus(`âŒ Errore creazione peer: ${error.message}`);
      }
    }

    socket.on("new-receiver", async ({ receiverId }) => {
      updateStatus(`ðŸŽ¯ Nuovo receiver: ${receiverId}`);
      for (const cubeIndex of [1, 2]) {
        const key = `${receiverId}-${cubeIndex}`;
        if (peers.has(key)) {
          peers.get(key).close();
          peers.delete(key);
          updateStatus(`â™»ï¸ Peer precedente chiuso per cubo ${cubeIndex}`);
        }
      }
      setTimeout(async () => {
        await createPeer(receiverId, 1);
        await createPeer(receiverId, 2);
        updateStatus(`âœ… Peers creati per receiver ${receiverId}`);
      }, 300);
    });

    socket.on("webrtc-answer", ({ from, answer, cubeIndex }) => {
      const key = `${from}-${cubeIndex}`;
      if (peers.has(key)) {
        peers.get(key).setRemoteDescription(new RTCSessionDescription(answer));
        updateStatus(`ðŸ›Žï¸ Answer ricevuto da ${from} per cubo ${cubeIndex}`);
      }
    });

    socket.on("webrtc-candidate", ({ from, candidate, cubeIndex }) => {
      const key = `${from}-${cubeIndex}`;
      if (peers.has(key)) {
        peers.get(key).addIceCandidate(new RTCIceCandidate(candidate));
        updateStatus(`ðŸ“¡ Candidate aggiunto per cubo ${cubeIndex}`);
      }
    });

    document.getElementById("start").onclick = () => {
      if (!selectedDeviceId) {
        alert("Seleziona una periferica audio prima di avviare lo streaming");
        return;
      }
      updateStatus("âœ… Sender pronto, in attesa di receivers...");
    };

    function sendPosition(index, x, y, z) {
      socket.emit("move-cube", { index, x, y, z });
      updateStatus(`ðŸ“¡ Posizione cubo ${index===1?'rosso':'verde'} inviata: x:${x.toFixed(2)}, y:${y.toFixed(2)}, z:${z.toFixed(2)}`);
    }

    document.getElementById("moveRed").onclick = () => sendPosition(1, Math.random()*4-2, 0, Math.random()*-4);
    document.getElementById("moveGreen").onclick = () => sendPosition(2, Math.random()*4-2, 0, Math.random()*-4);

    window.addEventListener('beforeunload', () => {
      peers.forEach(peer => peer.close());
      audioContexts.forEach(({ context, originalStream }) => {
        originalStream.getTracks().forEach(t => t.stop());
        if (context.state !== 'closed') context.close();
      });
    });

    (async () => {
      await requestAudioPermission();
      await enumerateDevices();
      updateStatus("ðŸŽ¬ Inizializzazione completata");
    })();
  </script>
</body>
</html>